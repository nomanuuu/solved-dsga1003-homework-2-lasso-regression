Download Link: https://assignmentchef.com/product/solved-dsga1003-homework-2-lasso-regression
<br>
In this homework you will investigate regression with <em>`</em><sub>1 </sub>regularization, both implementation techniques and theoretical properties. On the methods side, you’ll work on coordinate descent (the “shooting algorithm”), homotopy methods, and [optionally] projected SGD. On the theory side you’ll derive the largest <em>`</em><sub>1 </sub>regularization parameter you’ll ever need to try, and optionally you’ll derive the explicit solution to the coordinate minimizers used in coordinate descent, you’ll investigate what happens with ridge and lasso regression when you have two copies of the same feature, and you’ll work out the details of the classic picture that “explains” why <em>`</em><sub>1 </sub>regularization leads to sparsity.

<h2>1.1           Data Set and Programming Problem Overview</h2>

For the experiments, we are generating some artifical data using code in the file setup_problem.py. We are considering the regression setting with the 1-dimensional input space <strong>R</strong>. An image of the training data, along with the target function (i.e. the Bayes prediction function for the square loss function) is shown in Figure 1 below.

You can examine how the target function and the data were generated by looking at setup_problem.py.

The figure can be reproduced by running the LOAD_PROBLEM branch of the main function.

As you can see, the target function is a highly nonlinear function of the input. To handle this sort of problem with linear hypothesis spaces, we will need to create a set of features that perform nonlinear transforms of the input. A detailed description of the technique we will use can be found in the Jupyter notebook basis-fns.ipynb, included in the zip file.

In this assignment, we are providing you with a function that takes care of the featurization. This is the “featurize” function, returned by the generate_problem function in setup_problem.py. The generate_problem function also gives the true target function, which has been constructed to be a sparse linear combination of our features. The coefficients of this linear combination are also provided by generate_problem, so you can compare the coefficients of the linear functions you find to the target function coefficients. The generate_problem function also gives you the train and validation sets that you should use.

Figure 1: Training data and target function we will be considering in this assignment.

To get familiar with using the data, and perhaps to learn some techniques, it’s recommended that you work through the main() function of the include file ridge_regression.py. You’ll go through the following steps (on your own – no need to submit):

<ol>

 <li>Load the problem from disk into memory with load_problem.</li>

 <li>Use the featurize function to map from a one-dimensional input space to a <em>d</em>-dimensional feature space.</li>

 <li>Visualize the design matrix of the featurized data. (All entries are binary, so we will not do any data normalization or standardization in this problem, though you may experiment with that on your own.)</li>

 <li>Take a look at the class RidgeRegression. Here we’ve implemented our own RidgeRegression using the general purpose optimizer provided by scipy.optimize. This is primarily to introduce you to the sklearn framework, if you are not already familiar with it. It can help with hyperparameter tuning, as we will see shortly.</li>

 <li>Take a look at compare_our_ridge_with_sklearn. In this function, we want to get some evidence that our implementation is correct, so we compare to sklearn’s ridge regression. Comparing the outputs of two implementations is not always trivial – often the objective functions are slightly different, so you may need to think a bit about how to compare the results. In this case, sklearn has total square loss rather than average square loss, so we needed to account for that. In this case, we get an almost exact match with sklearn. This is because ridge regression is a rather easy objective function to optimize. You may not get as exact a match for other objective functions, even if both methods are “correct.”</li>

 <li>Next take a look at do_grid_search, in which we demonstrate how to take advantage of the fact that we’ve wrapped our ridge regression in an sklearn “Estimator” to do hyperparameter tuning. It’s a little tricky to get GridSearchCV to use the train/test split that you want, but</li>

</ol>

an approach is demonstrated in this function. In the line assigning the param_grid variable, you can see my attempts at doing hyperparameter search on a different problem. Below you will be modifying this (or using some other method, if you prefer) to find the optimal L2 regularization parameter for the data provided.

<ol start="7">

 <li>Next is some code to plot the results of the hyperparameter search.</li>

 <li>Next we want to visualize some prediction functions. We plotted the target function, along with several prediction functions corresponding to different regularization parameters, as functions of the original input space <strong>R</strong>, along with the training data. Next we visualize the coefficients of each feature with bar charts. Take note of the scale of the <em>y</em>-axis, as they may vary substantially, buy default.</li>

</ol>

<h1>2           Ridge Regression</h1>

In the problems below, you do not need to implement ridge regression. You may use any of the code provided in the assignment, or you may use other packages. However, your results must correspond to the ridge regression objective function that we use, namely

<em>.</em>

<ol>

 <li>Run ridge regression on the provided training dataset. Choose the <em>λ </em>that minimizes the empirical risk (i.e. the average square loss) on the validation set. Include a table of the parameter values you tried and the validation performance for each. Also include a plot of the results.</li>

 <li>Now we want to visualize the prediction functions. On the same axes, plot the following: the training data, the target function, an unregularized least squares fit (still using the featurized data), and the prediction function chosen in the previous problem. Next, along the lines of the bar charts produced by the code in compare_parameter_vectors, visualize the coefficients for each of the prediction functions plotted, including the target function. Describe the patterns, including the scale of the coefficients, as well as which coefficients have the most weight.</li>

 <li>For the chosen <em>λ</em>, examine the model coefficients. For ridge regression, we don’t expect any parameters to be exactly 0. However, let’s investigate whether we can predict the sparsity pattern of the true parameters (i.e. which parameters are 0 and which are nonzero) by thresholding the parameter estimates we get from ridge regression. We’ll predict that <em>w<sub>i </sub></em>= 0 if |<em>w</em>ˆ<em><sub>i</sub></em>| <em>&lt; ε </em>and <em>w<sub>i </sub></em>6= 0 Give the confusion matrix for <em>ε </em>= 10<sup>−6</sup><em>,</em>10<sup>−3</sup><em>,</em>10<sup>−1</sup>, and any other thresholds you would like to try.</li>

</ol>

<h1>3           Coordinate Descent for Lasso (a.k.a. The Shooting algorithm)</h1>

The Lasso optimization problem can be formulated as<sup>1</sup>

<em>m </em><em>w</em>ˆ ∈ argmin<sup>X</sup>(<em>h<sub>w</sub></em>(<em>x<sub>i</sub></em>) − <em>y<sub>i</sub></em>)<sup>2 </sup>+ <em>λ</em>k<em>w</em>k<sub>1</sub><em>, </em><em>w</em>∈<strong>R</strong><em><sup>d </sup>i</em>=1

where <em>h<sub>w</sub></em>(<em>x</em>) = <em>w<sup>T</sup>x</em>, and . Note that to align with Murpy’s formulation below, and for historical reasons, we are using the total square loss, rather than the average square loss, in the objective function.

Since the <em>`</em><sub>1</sub>-regularization term in the objective function is non-differentiable, it’s not immediately clear how gradient descent or SGD could be used to solve this optimization problem directly. (In fact, as we’ll see in the next homework on SVMs, we can use “subgradient” methods when the objective function is not differentiable, in addition to the two methods discussed in this homework assignment.)

Another approach to solving optimization problems is coordinate descent, in which at each step we optimize over one component of the unknown parameter vector, fixing all other components. The descent path so obtained is a sequence of steps, each of which is parallel to a coordinate axis in <strong>R</strong><em><sup>d</sup></em>, hence the name. It turns out that for the Lasso optimization problem, we can find a closed form solution for optimization over a single component fixing all other components. This gives us the following algorithm, known as the shooting algorithm:

(Source: Murphy, Kevin P. Machine learning: a probabilistic perspective. MIT press, 2012.) The “soft thresholding” function is defined as

soft(<em>a,δ</em>) = sign(<em>a</em>)(|<em>a</em>| − <em>δ</em>)<sub>+ </sub><em>,</em>

for any <em>a,δ </em>∈ <strong>R</strong>.

NOTE: Algorithm 13.1 does not account for the case that <em>a<sub>j </sub></em>= <em>c<sub>j </sub></em>= 0, which occurs when the <em>j</em>th column of <em>X </em>is identically 0. One can either eliminate the column (as it cannot possibly help the solution), or you can set <em>w<sub>j </sub></em>= 0 in that case since it is, as you can easily verify, the coordinate minimizer. Note also that Murphy is suggesting to initialize the optimization with the

1

ridge regession solution. Although theoretically this is not necessary (with exact computations and enough time, coordinate descent will converge for lasso from any starting point), in practice it’s helpful to start as close to the solution as we’re able.

There are a few tricks that can make selecting the hyperparameter <em>λ </em>easier and faster. First, as we’ll see in a later problem, you can show that for any <em>λ </em>≥ 2k<em>X<sup>T</sup></em>(<em>y </em>− <em>y</em>¯)k<sub>∞</sub>, the estimated weight vector <em>w</em>ˆ is entirely zero, where <em>y</em>¯ is the mean of values in the vector <em>y</em>, and k · k<sub>∞ </sub>is the infinity norm (or supremum norm), which is the maximum over the absolute values of the components of a vector. Thus we need to search for an optimal <em>λ </em>in [0<em>,λ</em><sub>max</sub>], where <em>λ</em><sub>max </sub>= 2k<em>X<sup>T</sup></em>(<em>y</em>−<em>y</em>¯)k<sub>∞</sub>. (Note: This expression for <em>λ</em><sub>max </sub>assumes we have an unregularized bias term in our model. That is, our decision functions are of the form <em>h<sub>w,b</sub></em>(<em>x</em>) = <em>w<sup>T</sup>x </em>+ <em>b</em>. In our the experiments, we do not have an unregularized bias term, so we should use <em>λ</em><sub>max </sub>= 2k<em>X<sup>T</sup>y</em>k<sub>∞</sub>.)

The second trick is to use the fact that when <em>λ </em>and <em>λ</em><sup>0 </sup>are close, the corresponding solutions <em>w</em>ˆ(<em>λ</em>) and <em>w</em>ˆ(<em>λ</em><sup>0</sup>) are also close. Start with <em>λ </em>= <em>λ</em><sub>max</sub>, for which we know <em>w</em>ˆ(<em>λ</em><sub>max</sub>) = 0. You can run the optimization anyway, and initialize the optimization at <em>w </em>= 0. Next, <em>λ </em>is reduced (e.g. by a constant factor close to 1), and the optimization problem is solved using the previous optimal point as the starting point. This is called warm starting the optimization. The technique of computing a set of solutions for a chain of nearby <em>λ</em>’s is called a continuation or homotopy method. The resulting set of parameter values <em>w</em>ˆ(<em>λ</em>) as <em>λ </em>ranges over [0<em>,λ</em><sub>max </sub>] is known as a regularization path.

<h2>3.1           Experiments with the Shooting Algorithm</h2>

<ol>

 <li>The algorithm as described above is not ready for a large dataset (at least if it has being implemented in Python) because of the implied loop in the summation signs for the expressions for <em>a<sub>j </sub></em>and <em>c<sub>j</sub></em>. Give an expression for computing <em>a<sub>j </sub></em>and <em>c<sub>j </sub></em>using matrix and vector operations, without explicit loops. This is called “vectorization” and can lead to dramatic speedup when implemented in languages such as Python, Matlab, and R. Write your expressions using <em>X</em>, <em>w</em>, <em>y </em>= (<em>y</em><sub>1</sub><em>,…,y<sub>n</sub></em>)<em><sup>T </sup></em>(the column vector of responses), <em>X</em><sub><em>j </em></sub>(the <em>j</em>th column of <em>X</em>, represented as a column matrix), and <em>w<sub>j </sub></em>(the <em>j</em>th coordinate of <em>w </em>– a scalar).</li>

 <li>Write a function that computes the Lasso solution for a given <em>λ </em>using the shooting algorithm described above. For convergence criteria, continue coordinate descent until a pass through the coordinates reduces the objective function by less than 10<sup>−8</sup>, or you have taken 1000 passes through the coordinates. Compare performance of cyclic coordinate descent to randomized coordinate descent, where in each round we pass through the coordinates in a different random order (for your choices of <em>λ</em>). Compare also the solutions attained (following the convergence criteria above) for starting at 0 versus starting at the ridge regression solution suggested by Murphy (again, for your choices of <em>λ</em>). If you like, you may adjust the convergence criteria to try to attain better results (or the same results faster).</li>

 <li>Run your best Lasso configuration on the training dataset provided, and select the <em>λ </em>that minimizes the square error on the validation set. Include a table of the parameter values you tried and the validation performance for each. Also include a plot of these results. Include also a plot of the prediction functions, just as in the ridge regression section, but this time add the best performing Lasso prediction function and remove the unregularized least squares fit. Similarly, add the lasso coefficients to the bar charts of coefficients generated in</li>

</ol>

the ridge regression setting. Comment on the results, with particular attention to parameter sparsity and how the ridge and lasso solutions compare. What’s the best model you found, and what’s its validation performance?

<ol start="4">

 <li>Implement the homotopy method described above. Compute the Lasso solution for (at least) the regularization parameters in the set. Plot the results (average validation loss vs <em>λ</em>).</li>

 <li>[Optional] Note that the data in Figure 1 is almost entirely nonnegative. Since we don’t have an unregularized bias term, we have “pay for” this offset using our penalized parameters. Note also that <em>λ</em><sub>max </sub>would decrease significantly if the <em>y </em>values were 0 centered (using the training data, of course), or if we included an unregularized bias term. Experiment with one or both of these approaches, for both and lasso and ridge regression, and report your findings.</li>

</ol>

<h2>3.2           [Optional] Deriving the Coordinate Minimizer for Lasso</h2>

This problem is to derive the expressions for the coordinate minimizers used in the Shooting algorithm. This is often <a href="https://davidrosenberg.github.io/mlcourse/Archive/2015/Lectures/2.Lab.subgradient-descent.pdf#page=15">derived using subgradients (slide 15)</a><a href="https://davidrosenberg.github.io/mlcourse/Archive/2015/Lectures/2.Lab.subgradient-descent.pdf#page=15">,</a> but here we will take a bare hands approach (which is essentially equivalent).

In each step of the shooting algorithm, we would like to find the <em>w<sub>j </sub></em>minimizing

<em>,</em>

where we’ve written <em>x<sub>ij </sub></em>for the <em>j</em>th entry of the vector <em>x<sub>i</sub></em>. This function is convex in <em>w<sub>j</sub></em>. The only thing keeping <em>f </em>from being differentiable is the term with |<em>w<sub>j</sub></em>|. So <em>f </em>is differentiable everywhere except <em>w<sub>j </sub></em>= 0. We’ll break this problem into 3 cases: <em>w<sub>j </sub>&gt; </em>0, <em>w<sub>j </sub>&lt; </em>0, and <em>w<sub>j </sub></em>= 0. In the first two cases, we can simply differentiate <em>f </em>w.r.t. <em>w<sub>j </sub></em>to get optimality conditions. For the last case, we’ll use the fact that since <em>f </em>: <strong>R </strong>→ <strong>R </strong>is convex, 0 is a minimizer of <em>f </em>iff

and      <em>.</em>

This is a special case of the optimality conditions described in <a href="https://github.com/davidrosenberg/mlcourse/blob/gh-pages/Archive/2017/Lectures/2.Lab.directional-derivatives.pdf#page=6">slide 6 here</a><a href="https://github.com/davidrosenberg/mlcourse/blob/gh-pages/Archive/2017/Lectures/2.Lab.directional-derivatives.pdf#page=6">,</a> where now the “direction” <em>v </em>is simply taken to be the scalars 1 and −1, respectively.

<ol>

 <li>First let’s get a trivial case out of the way. If <em>x<sub>ij </sub></em>= 0 for <em>i </em>= 1<em>,…,n</em>, what is the coordinate minimizer <em>w<sub>j</sub></em>? In the remaining questions below, you may assume that.</li>

 <li>Give an expression for the derivative <em>f</em>(<em>w<sub>j</sub></em>) for <em>w<sub>j </sub></em>6= 0. It will be convenient to write your expression in terms of the following definitions:</li>

</ol>



1        <em>w</em><em>j </em><em>&gt; </em>0

<table width="250">

 <tbody>

  <tr>

   <td width="62">sign(<em>w<sub>j</sub></em>)</td>

   <td width="27">:=</td>

   <td width="144">0             <em>w<sub>j </sub></em>= 0<sup></sup>−1     <em>w<sub>j </sub>&lt; </em>0</td>

   <td width="18"> </td>

  </tr>

  <tr>

   <td width="62"><em>a<sub>j</sub></em></td>

   <td width="27">:=</td>

   <td width="144"><em>n</em>2X<em>x</em>2<em>ij</em><em>i</em>=1</td>

   <td width="18"> </td>

  </tr>

  <tr>

   <td rowspan="2" width="62"><em>c<sub>j</sub></em></td>

   <td rowspan="2" width="27">:=</td>

   <td width="144">     <em><sub>n               </sub></em>X                             X</td>

   <td width="18"></td>

  </tr>

  <tr>

   <td colspan="2" width="161">2          <em>x</em><em>ij </em><em>y</em><em>i </em>−               <em>w</em><em>k</em><em>x</em><em>ik</em><em>.</em><em>i</em>=1                                       <em>k</em>6=<em>j</em></td>

  </tr>

 </tbody>

</table>

<ol start="3">

 <li>If <em>w<sub>j </sub>&gt; </em>0 and minimizes <em>f</em>, show that. Similarly, if <em>w<sub>j </sub>&lt; </em>0 and minimizes <em>f</em>, show that. Give conditions on <em>c<sub>j </sub></em>that imply that a minimizer <em>w<sub>j </sub></em>is positive and conditions for which a minimizer <em>w<sub>j </sub></em>is negative.</li>

 <li>Derive expressions for the two one-sided derivatives at <em>f</em>(0), and show that <em>c<sub>j </sub></em>∈ [−<em>λ,λ</em>] implies that <em>w<sub>j </sub></em>= 0 is a minimizer.</li>

 <li>Putting together the preceding results, we conclude the following:</li>

</ol>

Show that this is equivalent to the expression given in 3.

<h1>4           Lasso Properties</h1>

<h2>4.1           Deriving <em>λ</em>max</h2>

In this problem we will derive an expression for <em>λ</em><sub>max</sub>. For the first three parts, use the Lasso objective function excluding the bias term i.e,. We will show that for any <em>λ </em>≥ 2k<em>X<sup>T</sup>y</em>k<sub>∞</sub>, the estimated weight vector <em>w</em>ˆ is entirely zero, where k·k<sub>∞ </sub>is the infinity norm (or supremum norm), which is the maximum absolute value of any component of the vector.

<ol>

 <li>The one-sided directional derivative of <em>f</em>(<em>x</em>) at <em>x </em>in the direction <em>v </em>is defined as:</li>

</ol>

Compute <em>J</em><sup>0</sup>(0;<em>v</em>). That is, compute the one-sided directional derivative of <em>J</em>(<em>w</em>) at <em>w </em>= 0 in the direction <em>v</em>. [Hint: the result should be in terms of <em>X,y,λ, </em>and <em>v</em>.]

<ol start="2">

 <li>Since the Lasso objective is convex, <em>w</em><sup>∗ </sup>is a minimizer of <em>J</em>(<em>w</em>) if and only if the directional derivative <em>J</em><sup>0</sup>(<em>w</em><sup>∗</sup>;<em>v</em>) ≥ 0 for all <em>v </em>6= 0. Show that for any <em>v </em>6= 0, we have <em>J</em><sup>0</sup>(0;<em>v</em>) ≥ 0 if and only if <em>λ </em>≥ <em>C</em>, for some <em>C </em>that depends on <em>X,y, </em>and <em>v</em>. You should have an explicit expression for <em>C</em>.</li>

 <li>In the previous problem, we get a different lower bound on <em>λ </em>for each choice of <em>v</em>. Show that the maximum of these lower bounds on <em>λ </em>is <em>λ</em><sub>max </sub>= 2k<em>X<sup>T</sup>y</em>k<sub>∞</sub>. Conclude that <em>w </em>= 0 is a minimizer of <em>J</em>(<em>w</em>) if and only if <em>λ </em>≥ 2k<em>X<sup>T</sup>y</em>k<sub>∞</sub>.</li>

 <li>[Optional] Let, where <strong>1 </strong>∈ <strong>R</strong><em><sup>n </sup></em>is a column vector of 1’s.</li>

</ol>

Let <em>y</em>¯ be the mean of values in the vector <em>y</em>. Show that (<em>w</em><sup>∗</sup><em>,b</em><sup>∗</sup>) = (0<em>,y</em>¯) is a minimizer of <em>J</em>(<em>w,b</em>) if and only if <em>λ </em>≥ <em>λ</em><sub>max </sub>= 2k<em>X<sup>T</sup></em>(<em>y </em>− <em>y</em>¯)k<sub>∞</sub>.

<h2>4.2           Feature Correlation</h2>

In this problem, we will examine and compare the behavior of the Lasso and ridge regression in the case of an exactly repeated feature. That is, consider the design matrix <em>X </em>∈ <strong>R</strong><em><sup>m</sup></em><sup>×<em>d</em></sup>, where <em>X</em><sub>·<em>i </em></sub>= <em>X</em><sub>·<em>j </em></sub>for some <em>i </em>and <em>j</em>, where <em>X</em><sub>·<em>i </em></sub>is the <em>i<sup>th </sup></em>column of <em>X</em>. We will see that ridge regression divides the weight equally among identical features, while Lasso divides the weight arbitrarily. In an optional part to this problem, we will consider what changes when <em>X</em><sub>·<em>i </em></sub>and <em>X</em><sub>·<em>j </em></sub>are highly correlated (e.g. exactly the same except for some small random noise) rather than exactly the same.

<ol>

 <li>Without loss of generality, assume the first two colums of <em>X </em>are our repeated features. Partition <em>X </em>and <em>θ </em>as follows:</li>

</ol>

We can write the Lasso objective function as:

<em>J</em>(<em>θ</em>) =k<em>Xθ </em>− <em>y</em>k<sup>2</sup><sub>2 </sub>+ <em>λ</em>k<em>θ</em>k<sub>1</sub>

=k<em>x</em><sub>1</sub><em>θ</em><sub>1 </sub>+ <em>x</em><sub>2</sub><em>θ</em><sub>2 </sub>+ <em>X<sub>r</sub>θ<sub>r </sub></em>− <em>y</em>k<sup>2</sup><sub>2 </sub>+ <em>λ</em>|<em>θ</em><sub>1</sub>| + <em>λ</em>|<em>θ</em><sub>2</sub>| + <em>λ</em>k<em>θ<sub>r</sub></em><sup>k</sup><sub>1 </sub>With repeated features, there will be multiple minimizers of <em>J</em>(<em>θ</em>). Suppose that

is a minimizer of <em>J</em>(<em>θ</em>). Give conditions on <em>c </em>and <em>d </em>such that  is also a minimizer of <em>J</em>(<em>θ</em>). [Hint: First show that <em>a </em>and <em>b </em>must have the same sign, or at least one of them is zero.

Then, using this result, rewrite the optimization problem to derive a relation between <em>a </em>and <em>b</em>.]

<ol start="2">

 <li>Using the same notation as the previous problem, suppose</li>

</ol>

minimizes the ridge regression objective function. What is the relationship between <em>a </em>and <em>b</em>, and why?

<ol start="3">

 <li>[Optional] What do you think would happen with Lasso and ridge when <em>X</em><sub><em>i </em></sub>and <em>X</em><sub>·<em>j </em></sub>are highly correlated, but not exactly the same. You may investigate this experimentally or theoretically.</li>

</ol>

<h1>5           [Optional] The Ellipsoids in the <em>`</em><sub>1</sub><em>/`</em><sub>2 </sub>regularization picture</h1>

Recall the famous picture purporting to explain why <em>`</em><sub>1 </sub>regularization leads to sparsity, while <em>`</em><sub>2 </sub>regularization does not. Here’s the instance from Hastie et al’s <em>The Elements of Statistical Learning:</em>

(While Hastie et al. use <em>β </em>for the parameters, we’ll continue to use <em>w</em>.)

In this problem we’ll show that the level sets of the empirical risk are indeed ellipsoids centered at the empirical risk minimizer <em>w</em>ˆ.

Consider linear prediction functions of the form <em>x </em>7→ <em>w<sup>T</sup>x</em>. Then the empirical risk for <em>f</em>(<em>x</em>) = <em>w<sup>T</sup>x </em>under the square loss is

<em>.</em>

<ol>

 <li>[Optional] Let. Show that <em>w</em>ˆ has empirical risk given by</li>

 <li>[Optional] Show that for any <em>w </em>we have</li>

</ol>

<em>.</em>

Note that the RHS (i.e. “right hand side”) has one term that’s quadratic in <em>w </em>and one term that’s independent of <em>w</em>. In particular, the RHS does not have any term that’s linear in <em>w</em>. On the LHS (i.e. “left hand side”), we have. After expanding this out, you’ll have terms that are quadratic, linear, and constant in <em>w</em>. Completing the square is the tool for rearranging an expression to get rid of the linear terms. The following “completing the square” identity is easy to verify just by multiplying out the expressions on the RHS:

<ol start="3">

 <li>[Optional] Using the expression derived for <em>R</em><sup>ˆ</sup><em><sub>n</sub></em>(<em>w</em>) in 2, give a very short proof that <em>w</em>ˆ = is the empirical risk minimizer. That is:</li>

</ol>

<em>w</em>ˆ = argmin<em>R</em><sup>ˆ</sup><em><sub>n</sub></em>(<em>w</em>)<em>.</em>

<em>w</em>

Hint: Note that <em>X<sup>T</sup>X </em>is positive semidefinite and, by definition, a symmetric matrix <em>M </em>is positive semidefinite iff for all <em>x </em>∈ <strong>R</strong><em><sup>d</sup></em>, <em>x<sup>T</sup>Mx </em>≥ 0.

<ol start="4">

 <li>[Optional] Give an expression for the set of <em>w </em>for which the empirical risk exceeds the minimum empirical risk <em>R</em><sup>ˆ</sup><em><sub>n</sub></em>(<em>w</em>ˆ) by an amount <em>c &gt; </em>0. If <em>X </em>is full rank, then <em>X<sup>T</sup>X </em>is positive definite, and this set is an ellipse – what is its center?</li>

</ol>

<h1>6           [Optional] Projected SGD via Variable Splitting</h1>

In this question, we consider another general technique that can be used on the Lasso problem. We first use the variable splitting method to transform the Lasso problem to a differentiable problem with linear inequality constraints, and then we can apply a variant of SGD.

Representing the unknown vector <em>θ </em>as a difference of two non-negative vectors <em>θ</em><sup>+ </sup>and <em>θ</em><sup>−</sup>, the

<em>d                          d</em>

<em>`</em><sub>1</sub>-norm of <em>θ </em>is given by <sup>X</sup><em>θ<sub>i</sub></em><sup>+ </sup>+ <sup>X</sup><em>θ<sub>i</sub></em><sup>−</sup>. Thus, the optimization problem can be written as

<em>i</em>=1                      <em>i</em>=1

<em>m                                                                        d                             d</em>

(<em>θ</em>ˆ+<em>,θ</em>ˆ−) = argmin X(<em>h</em><em>θ</em>+<em>,θ</em>−(<em>x</em><em>i</em>) − <em>y</em><em>i</em>)2 + <em>λ</em>X<em>θ</em><em>i</em>+ + <em>λ</em>X<em>θ</em><em>i</em>−

<em>θ</em>+<em>,θ</em>−∈<strong>R</strong><em>d </em><em>i</em>=1 <em>i</em>=1 <em>i</em>=1 such that <em>θ</em><sup>+ </sup>≥ 0 and <em>θ</em><sup>− </sup>≥ 0<em>,</em>

where <em>h<sub>θ</sub></em>+<em><sub>,θ</sub></em>−(<em>x</em>) = (<em>θ</em><sup>+ </sup>−<em>θ</em><sup>−</sup>)<em><sup>T</sup>x</em>. The original parameter <em>θ </em>can then be estimated as <em>θ</em><sup>ˆ</sup>= (<em>θ</em><sup>ˆ</sup><sup>+ </sup>−<em>θ</em><sup>ˆ</sup><sup>−</sup>).

This is a convex optimization problem with a differentiable objective and linear inequality constraints. We can approach this problem using projected stochastic gradient descent, as discussed in lecture. Here, after taking our stochastic gradient step, we project the result back into the feasible set by setting any negative components of <em>θ</em><sup>+ </sup>and <em>θ</em><sup>− </sup>to zero.

<ol>

 <li>[Optional] Implement projected SGD to solve the above optimization problem for the same <em>λ</em>’s as used with the shooting algorithm. Since the two optimization algorithms should find essentially the same solutions, you can check the algorithms against each other. Report the differences in validation loss for each <em>λ </em>between the two optimization methods. (You can make a table or plot the differences.)</li>

 <li>[Optional] Choose the <em>λ </em>that gives the best performance on the validation set. Describe the solution <em>w</em>ˆ in term of its sparsity. How does the sparsity compare to the solution from the shooting algorithm?</li>

</ol>